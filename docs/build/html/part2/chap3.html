

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Chapter 3 Solving Problems by Searching &mdash; ArtificialIntelligence  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chapter 4 Search in Complex Environments" href="chap4.html" />
    <link rel="prev" title="Part 2 Problem-solving" href="index2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ArtificialIntelligence
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../part1/index1.html">Part 1 Artificial Intelligence</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index2.html">Part 2 Problem-solving</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Chapter 3 Solving Problems by Searching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#problem-solving-agents">3.1 Problem-Solving Agents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#search-problems-and-solutions">3.1.1 Search problems and solutions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formulating-problems">3.1.2 Formulating problems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-problems">3.2 Example Problems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#standardized-problems">3.2.1 Standardized problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-world-problems">3.2.2 Real-world problems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#search-algorithms">3.3 Search Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#best-first-search">3.3.1 Best-first search</a></li>
<li class="toctree-l4"><a class="reference internal" href="#search-data-structures">3.3.2 Search data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redundant-paths">3.3.3 Redundant paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measuring-problem-solving-performance">3.3.4 Measuring problem-solving performance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chap4.html">Chapter 4 Search in Complex Environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="chap5.html">Chapter 5</a></li>
<li class="toctree-l2"><a class="reference internal" href="chap6.html">Chapter 6</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ArtificialIntelligence</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index2.html">Part 2 Problem-solving</a> &raquo;</li>
        
      <li>Chapter 3 Solving Problems by Searching</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/part2/chap3.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\newcommand{\bs}{\boldsymbol}
\newcommand{\dp}{\displaystyle}
\newcommand{\rm}{\mathrm}
\newcommand{\cl}{\mathcal}
\newcommand{\pd}{\partial}\\\newcommand{\cd}{\cdot}
\newcommand{\cds}{\cdots}
\newcommand{\dds}{\ddots}
\newcommand{\lv}{\lVert}
\newcommand{\ol}{\overline}
\newcommand{\ra}{\rightarrow}
\newcommand{\rv}{\rVert}
\newcommand{\seq}{\subseteq}
\newcommand{\vds}{\vdots}
\newcommand{\wh}{\widehat}\\\newcommand{\0}{\boldsymbol{0}}
\newcommand{\1}{\boldsymbol{1}}
\newcommand{\a}{\boldsymbol{\mathrm{a}}}
\newcommand{\b}{\boldsymbol{\mathrm{b}}}
\newcommand{\c}{\boldsymbol{\mathrm{c}}}
\newcommand{\e}{\boldsymbol{\mathrm{e}}}
\newcommand{\f}{\boldsymbol{\mathrm{f}}}
\newcommand{\g}{\boldsymbol{\mathrm{g}}}
\newcommand{\i}{\boldsymbol{\mathrm{i}}}
\newcommand{\j}{\boldsymbol{j}}
\newcommand{\n}{\boldsymbol{\mathrm{n}}}
\newcommand{\p}{\boldsymbol{\mathrm{p}}}
\newcommand{\q}{\boldsymbol{\mathrm{q}}}
\newcommand{\r}{\boldsymbol{\mathrm{r}}}
\newcommand{\u}{\boldsymbol{\mathrm{u}}}
\newcommand{\v}{\boldsymbol{\mathrm{v}}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\x}{\boldsymbol{\mathrm{x}}}
\newcommand{\y}{\boldsymbol{\mathrm{y}}}\\\newcommand{\A}{\boldsymbol{\mathrm{A}}}
\newcommand{\B}{\boldsymbol{B}}
\newcommand{\C}{\boldsymbol{C}}
\newcommand{\D}{\boldsymbol{\mathrm{D}}}
\newcommand{\I}{\boldsymbol{\mathrm{I}}}
\newcommand{\K}{\boldsymbol{\mathrm{K}}}
\newcommand{\N}{\boldsymbol{\mathrm{N}}}
\newcommand{\P}{\boldsymbol{\mathrm{P}}}
\newcommand{\S}{\boldsymbol{\mathrm{S}}}
\newcommand{\U}{\boldsymbol{\mathrm{U}}}
\newcommand{\W}{\boldsymbol{\mathrm{W}}}
\newcommand{\X}{\boldsymbol{\mathrm{X}}}\\\newcommand{\R}{\mathbb{R}}\\\newcommand{\ld}{\lambda}
\newcommand{\Ld}{\boldsymbol{\mathrm{\Lambda}}}
\newcommand{\sg}{\sigma}
\newcommand{\Sg}{\boldsymbol{\mathrm{\Sigma}}}
\newcommand{\th}{\theta}\\\newcommand{\mmu}{\boldsymbol{\mu}}\\\newcommand{\bb}{\begin{bmatrix}}
\newcommand{\eb}{\end{bmatrix}}
\newcommand{\bp}{\begin{pmatrix}}
\newcommand{\ep}{\end{pmatrix}}
\newcommand{\bv}{\begin{vmatrix}}
\newcommand{\ev}{\end{vmatrix}}\\\newcommand{\im}{^{-1}}
\newcommand{\pr}{^{\prime}}
\newcommand{\ppr}{^{\prime\prime}}
\newcommand{\-}{\mbox{-}}\end{aligned}\end{align} \]</div>
<div class="section" id="chapter-3-solving-problems-by-searching">
<h1>Chapter 3 Solving Problems by Searching<a class="headerlink" href="#chapter-3-solving-problems-by-searching" title="Permalink to this headline">¶</a></h1>
<p>When the correct action to take is not immediately obvious, an agent may need to
<em>plan ahead</em>: to consider a <em>sequence</em> of actions that form a path to a goal
state.
Such an agent is called a <strong>problem-solving agent</strong>, and the computational process it undertakes is called <strong>search</strong>.</p>
<p>Problem-solving agents use <strong>atomic</strong> representations, that is, states of the
world are considered as wholes, with no internal structure visible to the
problem-solving algorithms.
Agents that use <strong>factored</strong> or <strong>structured</strong> representations of states are called <strong>planning agents</strong>.</p>
<p>We distinguish between <strong>informed</strong> algorithms, in which the agent can estimate
how far it is from the goal, and <strong>uninformed</strong> algorithms, where no such
estimate is available.</p>
<div class="section" id="problem-solving-agents">
<h2>3.1 Problem-Solving Agents<a class="headerlink" href="#problem-solving-agents" title="Permalink to this headline">¶</a></h2>
<p>If the agent has no additional information—that is, if the environment is
<strong>unknown</strong>—then the agent can do no better than to execute one of the actions
at random.
For now, we assume that our agents always have access to information about the world.
With that information, the agent can follow this four-phase problem-solving process:</p>
<ul class="simple">
<li><p><strong>GOAL FORMULATION</strong>: Goals organize behavior by limiting the objectives and hence the actions to be considered.</p></li>
<li><p><strong>PROBLEM FORMULATION</strong>: The agent devises a description of the states and
actions necessary to reach the goal—an abstract model of the relevant part of
the world.</p></li>
<li><p><strong>SEARCH</strong>: Before taking any action in the real world, the agent simulates
sequences of actions in its model, searching until it finds a sequence of
actions that reaches the goal.
Such a sequence is called a <strong>solution</strong>.</p></li>
<li><p><strong>EXECUTION</strong>: The agent can now execute the actions in the solution, one at a time.</p></li>
</ul>
<p>It is an important property that in a fully observable, deterministic, known
environment, <em>the solution to any problem is a fixed sequence of actions</em>.
The <strong>open-loop</strong> system means that ignoring the percepts breaks the loop between agent and environment.
If there is a chance that the model is incorrect, or the environment is
nondeterministic, then the agent would be safer using a <strong>closed-loop</strong> approach
that monitors the percepts.</p>
<p>In partially observable or nondeterministic environments, a solution would be a
branching strategy that recommends different future actions depending on what
percepts arrive.</p>
<div class="section" id="search-problems-and-solutions">
<h3>3.1.1 Search problems and solutions<a class="headerlink" href="#search-problems-and-solutions" title="Permalink to this headline">¶</a></h3>
<p>A search <strong>problem</strong> can be defined formally as follows:</p>
<ul class="simple">
<li><p>A set of possible <strong>states</strong> that the environment can be in.
We call this the <strong>state space</strong>.</p></li>
<li><p>The <strong>initial state</strong> that the agent starts in.</p></li>
<li><p>A set of one or more <strong>goal states</strong>.
We can account for all three of these possibilities by specifying an <span class="math notranslate nohighlight">\(Is\-Goal\)</span> method for a problem.</p></li>
<li><p>The <strong>actions</strong> available to the agent.
Given a state <span class="math notranslate nohighlight">\(s\)</span>, <span class="math notranslate nohighlight">\(Actions(s)\)</span> returns a finite set of
actions that can be executed in <span class="math notranslate nohighlight">\(s\)</span>.
We say that each of these actions is <strong>applicable</strong> in <span class="math notranslate nohighlight">\(s\)</span>.</p></li>
<li><p>A <strong>transition model</strong>, which describes what each action does.
<span class="math notranslate nohighlight">\(Result(s,a)\)</span> returns the state that results from doing action <span class="math notranslate nohighlight">\(a\)</span> in state <span class="math notranslate nohighlight">\(s\)</span>.</p></li>
<li><p>An <strong>action cost function</strong>, denote by <span class="math notranslate nohighlight">\(Action\-Cost(s,a,s\pr)\)</span> when we
are programming or <span class="math notranslate nohighlight">\(c(s,a,s\pr)\)</span> when we are doing math, that gives the
numeric cost of applying action <span class="math notranslate nohighlight">\(a\)</span> in state <span class="math notranslate nohighlight">\(s\)</span> to reach state
<span class="math notranslate nohighlight">\(s\pr\)</span>.</p></li>
</ul>
<p>A sequence of actions forms a <strong>path</strong>, and a <strong>solution</strong> is a path from the
initial state to a goal state.
We assume that action costs are additive; that is, the total cost of a path is
the sum of the individual action costs.
An <strong>optimal solution</strong> has the lowest path cost among all solutions.</p>
<p>The state space can be represented as a <strong>graph</strong> in which the vertices are
states and the directed edges between them are actions.</p>
</div>
<div class="section" id="formulating-problems">
<h3>3.1.2 Formulating problems<a class="headerlink" href="#formulating-problems" title="Permalink to this headline">¶</a></h3>
<p>The process of removing detail from a representation is called <strong>abstraction</strong>.
The abstraction is <em>valid</em> if we can elaborate any abstract solution into a
solution in the more detailed world.
The abstraction is <em>useful</em> if carrying out each of the actions in the solution
is easier than the original problem.</p>
</div>
</div>
<div class="section" id="example-problems">
<h2>3.2 Example Problems<a class="headerlink" href="#example-problems" title="Permalink to this headline">¶</a></h2>
<p>A <strong>standardized problem</strong> is intended to illustrate or exercise various problem-solving methods.
It can be given a concise, exact description and hence is suitable as a
benchmark for researchers to compare the performance of algorithms.
A <strong>real-world problem</strong>, such as robot navigation, is one whose solutions
people actually use, and whose formulation is idiosyncratic, not standardized,
because, for example, each robot has different sensors that produce different
data.</p>
<div class="section" id="standardized-problems">
<h3>3.2.1 Standardized problems<a class="headerlink" href="#standardized-problems" title="Permalink to this headline">¶</a></h3>
<p>A <strong>grid world</strong> problem is a two-dimensional rectangular array of square cells
in which agents can move from cell to cell.</p>
<ul class="simple">
<li><p><strong>Vacuum world</strong></p></li>
<li><p><strong>Sokoban puzzle</strong></p></li>
<li><p><strong>Sliding-tile puzzle</strong></p></li>
</ul>
</div>
<div class="section" id="real-world-problems">
<h3>3.2.2 Real-world problems<a class="headerlink" href="#real-world-problems" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>Route-finding problem</strong></p></li>
<li><p><strong>Touring problems</strong></p></li>
<li><p><strong>Trveling salesperson problem (TSP)</strong></p></li>
<li><p><strong>VLSI layout problem</strong></p></li>
<li><p><strong>Robot navigation</strong></p></li>
<li><p><strong>Automatic assembly sequencing</strong></p></li>
</ul>
</div>
</div>
<div class="section" id="search-algorithms">
<h2>3.3 Search Algorithms<a class="headerlink" href="#search-algorithms" title="Permalink to this headline">¶</a></h2>
<p>A <strong>search algorithm</strong> takes a search problem as input and returns a solution, or an indication of failure.
We consider algorithms that superimpose a <strong>search tree</strong> over the state-space
graph, forming various paths from the initial state, trying to find a path that
reaches a goal state.
Each <strong>node</strong> in the search tree corresponds to a state in the state space and
the edges in the search tree correspond to actions.
The root of the tree corresponds to the initial state of the problem.</p>
<p>The state space describes the (possibly infinite) set of states in the world,
and the actions that allow transitions from one state to another.
The search tree describes paths between these states, reaching towards the goal.
The search tree may have multiple paths to (and thus multiple nodes for) any
given state, but each node in the tree has a unique path back to the root (as in
all trees).</p>
<p>The <strong>frontier</strong> separates two regions of the state-space graph: an interior
region where every state has been expanded, and an exterior region of states
that have not yet been reached.</p>
<div class="section" id="best-first-search">
<h3>3.3.1 Best-first search<a class="headerlink" href="#best-first-search" title="Permalink to this headline">¶</a></h3>
<p>In <strong>best-first search</strong> we choose a node, <span class="math notranslate nohighlight">\(n\)</span>, with minimum value of some <strong>evaluation function</strong>, <span class="math notranslate nohighlight">\(f(n)\)</span>.</p>
<img alt="../_images/Fig3.7.png" src="../_images/Fig3.7.png" />
</div>
<div class="section" id="search-data-structures">
<h3>3.3.2 Search data structures<a class="headerlink" href="#search-data-structures" title="Permalink to this headline">¶</a></h3>
<p>A <strong>node</strong> in the tree is represented by a data structure with four components</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(node.State\)</span>: the state to which the node corresponds;</p></li>
<li><p><span class="math notranslate nohighlight">\(node.Parent\)</span>: the node in the tree that generated this node;</p></li>
<li><p><span class="math notranslate nohighlight">\(node.Action\)</span>: the action that was applied to the parent’s state to generate this node;</p></li>
<li><p><span class="math notranslate nohighlight">\(node.Path-Cost\)</span>: the total cost of the path from the initial state to this node.
In mathematical formulas, we use <span class="math notranslate nohighlight">\(g(node)\)</span> as a synonym for <span class="math notranslate nohighlight">\(Path\-Cost\)</span>.</p></li>
</ul>
<p>Following the <span class="math notranslate nohighlight">\(PARENT\)</span> pointers back from a node allows us to recover the
states and actions along the path to that node.
Doing this from a goal node gives us the solution.</p>
<p>We need a data structure to store the <strong>frontier</strong>.
The appropriate choice is a <strong>queue</strong> of some kind, because the operations on a frontier are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Is\-Empty(frontier)\)</span> returns true only if there are no nodes in the frontier.</p></li>
<li><p><span class="math notranslate nohighlight">\(Pop(frontier)\)</span> removes the top node from the frontier and returns it.</p></li>
<li><p><span class="math notranslate nohighlight">\(Top(frontier)\)</span> returns (but does not remove) the top node of the frontier.</p></li>
<li><p><span class="math notranslate nohighlight">\(Add(node, frontier)\)</span> inserts node into its proper place in the queue.</p></li>
</ul>
<p>Three kinds of queues are used in search algorithms:</p>
<ul class="simple">
<li><p>A <strong>priority queue</strong> first pops the node with the minimum cost according to some evaluation function, <span class="math notranslate nohighlight">\(f\)</span>.
It is used in best-first search.</p></li>
<li><p>A <strong>FIFO queue</strong> or first-in-first-out queue first pops the node that was added to
the queue first; we shall see it is used in breadth-first search.</p></li>
<li><p>A <strong>LIFO queue</strong> or last-in-first-out queue (also known as a <strong>stack</strong>) pops
first the most recently added node; we shall see it is used in depth-first
search.</p></li>
</ul>
</div>
<div class="section" id="redundant-paths">
<h3>3.3.3 Redundant paths<a class="headerlink" href="#redundant-paths" title="Permalink to this headline">¶</a></h3>
<p>A cycle is a special case of a <strong>redundant path</strong>.</p>
<p>As the saying goes, <em>algorithms that cannot remember the past are doomed to repeat it</em>.
There are three approaches to this issue.</p>
<p>First, we can remember all previously reached states (as best-first search
does), allowing us to detect all redundant paths, and keep only the best path
to each state.</p>
<p>Second, we can not worry about repeating the past.
We call a search algorithm a <strong>graph search</strong> if it checks for redundant paths
and a <strong>tree-like search</strong> if it does not check.</p>
<p>Third, we can compromise and check for cycles, but not for redundant paths in general.</p>
</div>
<div class="section" id="measuring-problem-solving-performance">
<h3>3.3.4 Measuring problem-solving performance<a class="headerlink" href="#measuring-problem-solving-performance" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>COMPLETENESS</strong>: Is the algorithm guaranteed to find a solution when there is
one, and to correctly report failure when there is not?</p></li>
<li><p><strong>COST OPTIMALITY</strong>: Does it find a solution with the lowest path cost of all solutions?</p></li>
<li><p><strong>TIME COMPLEXITY</strong>: How long does it take to find a solution?</p></li>
<li><p><strong>SPACE COMPLEXITY</strong>: How much memory is needed to perform the search?</p></li>
</ul>
<p>To be complete, a search algorithm must be <strong>systematic</strong> in the way it explores
an infinite state space, making sure it can eventually reach any state that is
connected to the initial state.</p>
<p>In theoretical computer science, the typical measure of time and space
complexity is the size of the state-space graph, <span class="math notranslate nohighlight">\(|V|+|E|\)</span>, where
<span class="math notranslate nohighlight">\(|V|\)</span> is the number of vertices (state nodes) of the graph and <span class="math notranslate nohighlight">\(|E|\)</span>
is the number of edges (distinct state/action pairs).
For an implicit state space, complexity can be measured in terms of <span class="math notranslate nohighlight">\(d\)</span>,
the <strong>depth</strong> or number of actions in an optimal solution; <span class="math notranslate nohighlight">\(m\)</span>, the
maximum number of actions in any path; and <span class="math notranslate nohighlight">\(b\)</span>, the <strong>branching factor</strong>
or number of successors of a node that need to be considered.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="chap4.html" class="btn btn-neutral float-right" title="Chapter 4 Search in Complex Environments" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index2.html" class="btn btn-neutral float-left" title="Part 2 Problem-solving" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Ziniu Yu.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>